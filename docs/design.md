## Design doc: vleet (Vim + LeetCode in the terminal)

### Summary

**vleet is a terminal-only CLI that lets a user fetch a LeetCode problem, edit a solution in Vim, submit it to LeetCode, and display the submission result.**

The MVP is intentionally simple:

- **Problem fetch**: Given a problem key (initially `titleSlug`), fetch all relevant problem context from LeetCode.
- **Edit**: Generate a workspace with a single `solution.<ext>` that starts with the problem statement in comments, followed by LeetCode’s official starter snippet, then open Vim.
- **Submit**: Submit the code to LeetCode for the selected language.
- **Results**: Poll until finished and print verdict + details.

### Goals

- **Terminal-only UX**: No browser UI; can launch an editor (`vim`/`nvim`) as a subprocess.
- **Full problem context**: Title, difficulty, description, examples, constraints, hints (if available), tags, and the official starter snippet for the chosen language.
- **Language selection**: User chooses language; default to **C++** (`cpp`).
- **Reliable submission loop**: Submit, poll, and render verdicts including compile errors and runtime/memory details.
- **Minimal setup**: Works with a single CLI binary + a small config file.

### Tool implementation language (vleet itself)

The **vleet CLI is intended to be implemented in Go** (recommended for a terminal-only, single-binary tool with strong HTTP/TLS and simple concurrency). This is **independent** of the language you solve LeetCode problems in (default is C++).

### Non-goals (MVP)

- **No local judge / sandbox**: vleet will not execute code against hidden tests.
- **No embedded Vim**: We’ll launch an external editor process.
- **No full-screen TUI required**: Plain CLI output is acceptable; we can add a Bubble Tea TUI later.
- **No account creation / login automation**: We will not automate username/password login (fragile + potentially blocked). We’ll use user-provided session credentials (cookie/token).
- **No guarantee for premium content**: Premium problems may require an authenticated session; we will handle errors gracefully.

### User experience (MVP)

#### Primary command: solve

Proposed:

```bash
vleet solve <problem-key> --lang cpp
```

Behavior:

- Resolve `<problem-key>` to a LeetCode `titleSlug` (MVP: require slug; later: support numeric IDs).
- Fetch problem context from LeetCode.
- Create a workspace directory if it doesn't already exist in the current directory:
  - `<problem-key>` would be the workspace dir name with the following layout:
    - There will be one file per language called `solution.<language-extension>` (overridable via `--file`)
    - Each solution file will have a commented header block with all the
      context for the problem from leetcode.
    - **Header comment block** generated by vleet:
      - title, difficulty, tags, URL
      - statement + examples + constraints (from LeetCode `content`)
    - **LeetCode starter snippet** pasted *verbatim* from `codeSnippets` for the selected language (this preserves the same “editor boilerplate” comments/definitions LeetCode provides).
  - No per-workspace metadata file is required:
    - the workspace dir name is the problem key (`titleSlug`)
    - the language is provided via `--lang` (and/or inferred from the file extension)
    - `question_id` is re-fetched from LeetCode at submit time
- Launch editor:
  - default: `vim ./<problem-key>/solution.<ext>`
  - configurable via `$EDITOR` or `vleet config set editor nvim`
- After editor exits:
  - if `--submit` is passed, submit immediately
  - otherwise prompt: “Submit to LeetCode? [y/N]”
- Poll until completion and print result summary.

#### Other commands (MVP-friendly)

- `vleet fetch <problem-key> --lang <lang>`: print/render the statement and/or generate `solution.<ext>` without opening an editor.
- `vleet submit <problem-key> --lang <lang>`: submit from an existing workspace (reads `./<problem-key>/solution.<ext>` by default; `--file` can override).
- `vleet config set ...` / `vleet config show`: manage auth + defaults.

### Problem key semantics

MVP:

- **`problem-key` = LeetCode `titleSlug`**, e.g. `two-sum`, `merge-k-sorted-lists`.

Planned:

- Support **numeric keys** (e.g. `1`) by querying the problem list and mapping number → slug.
- Support searching by title keywords (`vleet search "two sum"`).

### LeetCode integration (MVP)

LeetCode is not an officially supported public API. In practice, two endpoints are sufficient:

- **GraphQL**: fetch problem data
- **REST**: submit code and poll status

#### Fetch: GraphQL

Endpoint (US):

- `https://leetcode.com/graphql`

We use a GraphQL query like `questionData` with `titleSlug`.

Fields we need (typical):

- `questionId` / `questionFrontendId`
- `title`, `titleSlug`
- `difficulty`
- `content` (HTML)
- `exampleTestcases`, `sampleTestCase`
- `hints` (if available)
- `topicTags` (name + slug)
- `codeSnippets` (language + code)  ← critical for a good Vim UX

We will convert LeetCode `content` (HTML) into comment-friendly text and **prepend it as the header comment block** at the top of `solution.<ext>`.

#### Submit: REST

Submit:

- `POST https://leetcode.com/problems/<slug>/submit/`
- JSON payload:
  - `lang`: LeetCode language slug (e.g. `cpp`, `python3`, `golang`)
  - `question_id`: numeric question id (not frontend id)
  - `typed_code`: file contents

Response includes a `submission_id` (or errors).

Poll:

- `GET https://leetcode.com/submissions/detail/<submission_id>/check/`
- Poll every ~1s (with exponential backoff and a max timeout).

Render:

- Final verdict: Accepted / Wrong Answer / TLE / MLE / Runtime Error / Compile Error
- Show runtime/memory and, when available, failure input/output diagnostics.

#### Auth model (practical + robust)

To submit, the user must be logged in on LeetCode.

MVP approach:

- User provides **`LEETCODE_SESSION`** cookie value (and optionally `csrftoken`).
- vleet stores these in its config with strict file permissions (`0600`).
- For requests:
  - attach cookies
  - set `Referer` to the problem page
  - set `x-csrftoken` header

Notes:

- vleet should never print these values to stdout/stderr.
- If the session expires, the error should explain how to refresh it.

### Workspace layout

Workspaces are created **in the current working directory**:

- Workspace dir: `./<problem-key>/` (e.g. `./two-sum/`)
- Each workspace contains **one solution file per language**, using a stable base name:
  - `solution.cpp` (default)
  - `solution.go`
  - `solution.py`
  - You can override the filename (for embedding static metadata) with `--file` as long as the extension matches the language (e.g. `--file two-sum.cpp`).

vleet avoids `.vleet.json` by deriving required data from:

- **problem key**: directory name (`<problem-key>`)
- **language**: `--lang` and/or file extension
- **question_id**: fetched from LeetCode at submission time

### Language handling

We’ll represent each language with exactly one identifier which be 
exactly equal to the leetcode language slug:

- **LeetCode `lang` slug**: `golang`, `python3`, `cpp`, …

We will also map languages to:

- file extension (`.go`, `.py`, `.cpp`)
- editor filetype hints (optional)

MVP list (expandable):

- `cpp` → `.cpp` (default)
- `golang` → `.go`
- `python3` → `.py`
- `javascript` → `.js`
- `typescript` → `.ts`

We should prefer using the exact language strings returned in `codeSnippets` to avoid mismatch.

### Rendering the problem statement

LeetCode `content` is HTML. For Vim friendliness:

- Convert HTML → comment-friendly text (preserve code blocks, lists, and spacing as much as practical).
- Prepend metadata (title, difficulty, tags, URL).
- Include examples and constraints when present.
- Write the result as a **header comment block** at the top of `solution.<ext>`.
- Immediately after the vleet header, paste the **exact LeetCode starter snippet** for the chosen language (from `codeSnippets`), so the next comment section matches what the LeetCode editor provides (e.g., struct/class definitions).

If conversion fails, we can:

- fallback to plain text by stripping tags (still embedded in the header comment)
- optionally store raw HTML in a global cache (e.g. `~/.cache/vleet/`) for debugging (not opened by default)

### Error handling / failure modes (MVP)

- **Network failures**: retries with backoff; clear message.
- **Invalid slug**: “Problem not found” with suggestion to check the slug.
- **Auth missing/expired**: “Submission requires LeetCode session. Run `vleet config set leetcode_session ...`”.
- **Blocked/captcha**: detect HTML responses where JSON is expected; explain that LeetCode may be blocking automated requests and recommend re-auth or slower polling.
- **Unsupported language**: list supported languages and show what LeetCode offers for that problem.
- **Editor not found**: explain how to set `$EDITOR` or config.

### Security and privacy

- **Secrets**: session cookies are secrets.
  - store with permissions `0600`
  - never log/print
  - redact in debug traces
- **TLS**: rely on system root CAs; do not disable verification.
- **Least data**: cache only what’s needed (problem statement + metadata + user solution).

### Observability

- Default output: human-readable.
- Optional `--json` output for CI/automation: fetch metadata, final submission result, error codes.
- Optional `--debug` for request/response metadata (never bodies containing secrets).

### Testing strategy (initial)

- Unit tests for:
  - language mapping + snippet selection
  - HTML → comment-header conversion (golden tests)
  - polling state machine (using `httptest` to simulate check endpoint)
- Integration test (optional/manual):
  - run `vleet solve two-sum --submit` with a known working session cookie

### MVP milestones

 - **M0**: CLI skeleton + config read/write (editor, default solve language, session cookie)
- **M1**: Fetch problem via GraphQL and generate `solution.<ext>` (header comment + starter snippet)
- **M2**: Launch Vim and return cleanly
- **M3**: Submit + poll + render results
- **M4**: `vleet submit` from existing workspace; basic caching

### Risks / mitigations

- **LeetCode changes endpoints or blocks requests**
  - mitigate with well-structured client, conservative polling, and clear errors
- **HTML rendering inconsistencies**
  - mitigate with robust converter and fallbacks
- **Auth storage concerns**
  - mitigate with `0600` and (later) OS keychain support
